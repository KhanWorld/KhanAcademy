import logging
import inspect

# request_cache is similar to layer_cache, except it only memoizes results
# for each individual request. If you need to cache results for longer than
# a single request, use layer_cache.
#
# _____Explanation by examples:_____
#
# import request_cache
#
# @request_cache.cache()
# def calculate_user_averages():
# ... do lots of long-running work...
#
# Cache using key generated by utility function that
# varies the key based on the function's input parameters:
#
# @request_cache.cache_with_key_fxn(lambda object: "request_cache_key_for_object_%s" % object.id())
# def calculate_object_average(object):
#   ... do lots of long-running work...
#   return result_for_cache

CACHE = {}

def accepts_kwargs(target):
    args, varargs, varkw, defaults = inspect.getargspec(target)
    return varkw is not None

def cache():
    def decorator(target):
        key = "__request_cache_%s.%s__" % (target.__module__, target.__name__)
        def wrapper(*args, **kwargs):
            return request_cache_check_set_return(target, lambda *args, **kwargs: key, *args, **kwargs)

        return wrapper
    return decorator

def cache_with_key_fxn(key_fxn):
    def decorator(target):
        def wrapper(*args, **kwargs):
            return request_cache_check_set_return(target, key_fxn, *args, **kwargs)
        return wrapper
    return decorator

def request_cache_check_set_return(
        target,
        key_fxn,
        *args,
        **kwargs):

    key = key_fxn(*args, **kwargs)

    bust_cache = False
    if "bust_cache" in kwargs:
        bust_cache = kwargs["bust_cache"]
        if not accepts_kwargs(target):
            # delete from kwargs so it's not passed to the target
            del kwargs["bust_cache"]

    if not bust_cache:
        if has(key):
            return get(key)

    result = target(*args, **kwargs)

    # In case the key's value has been changed by target's execution
    key = key_fxn(*args, **kwargs)

    set(key, result)

    return result

def has(key):
    global CACHE
    return key in CACHE

def get(key):
    global CACHE

    if not has(key):
        return None

    return CACHE[key]

def set(key, value, **kwargs):
    global CACHE
    CACHE[key] = value

def flush():
    global CACHE
    CACHE = {}

class RequestCacheMiddleware(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        # Clear the cache at the beginning of every request. Since GAE's Python
        # environment is single-threaded per instance, each individual request
        # is guaranteed to start w/ a unique, empty CACHE dict.
        flush()
        return self.app(environ, start_response)
